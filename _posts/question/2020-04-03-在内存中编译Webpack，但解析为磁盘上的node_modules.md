---
layout: question
title:  在内存中编译Webpack，但解析为磁盘上的node_modules
date:   2020-04-03T02:50:36.000Z
description: 我正在尝试使用网络包来编译内存中有效的JavaScript代码的字符串。我正在使用此处概述的内存fs：https   //webpack.github.i...
img: 
author: 小宇宙
category: question
answer: 1
tags: JavaScript Webpack
topic: Webpack
---
<div class="article-root">
  <div class="article">
    {% include articleTitle.html info=page %}
    {% raw %}
    <div class="article-content"><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我正在尝试使用网络包来编译内存中有效的JavaScript代码的字符串。</font><font style="vertical-align: inherit;">我正在使用此处概述的内存fs：</font></font><a href="https://webpack.github.io/docs/node.js-api.html#compile-to-memory"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font><a href="https://webpack.github.io/docs/node.js-api.html#compile-to-memory"><font style="vertical-align: inherit;">//webpack.github.io/docs/node.js-api.html#compile-to-memory</font></a><font style="vertical-align: inherit;">。</font></font></p>

<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此，我采用了一个包含原始javascript的字符串，将其写入内存fs，然后Web pack解析为该入口点。</font><font style="vertical-align: inherit;">但是编译在第一个require语句上失败，大概是因为它无法在node_modules的真实fs中查找。</font></font></p>

<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">关于如何完成此操作的任何想法？</font></font></p>

<pre><code>import webpack from 'webpack';<font></font>
import MemoryFS from 'memory-fs';<font></font>
import thenify from 'thenify';<font></font>
<font></font>
function* compile(code) {<font></font>
    const fs = new MemoryFS();<font></font>
    fs.writeFileSync('/file.js', code);<font></font>
    const compiler = webpack({<font></font>
        entry: { file: '/file.js' },<font></font>
        output: {<font></font>
            path: '/build',<font></font>
            filename: '[name].js'<font></font>
        },<font></font>
        module: {<font></font>
            loaders: [<font></font>
                { test: /\.json$/, loader: 'json' }<font></font>
            ],  <font></font>
        }<font></font>
    });<font></font>
    compiler.run = thenify(compiler.run);<font></font>
<font></font>
    compiler.inputFileSystem = fs;<font></font>
    compiler.resolvers.normal.fileSystem = fs; //this is needed for memfs<font></font>
    compiler.outputFileSystem = fs;<font></font>
    const stats = yield compiler.run();<font></font>
    //retrieve the output of the compilation<font></font>
    const res = stats.compilation.assets['file.js'].source();<font></font>
    return res;<font></font>
}<font></font>
</code></pre>

<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用法</font></font></p>

<pre><code>var code = "var _ = require('underscore'); console.log(_);";<font></font>
var bundle = yield compile(code); //should be a bundle containing the underscore source.<font></font>
</code></pre>

<p>The error is </p>

<blockquote>
  <p>ModuleNotFoundError: Module not found: Error: Cannot resolve module
  underscore in /</p>
</blockquote>

<p>This question indicates that others have tried the same thing: <a href="https://github.com/webpack/webpack/issues/1562">https://github.com/webpack/webpack/issues/1562</a>. there's a gist referenced at <a href="https://gist.github.com/DatenMetzgerX/2a96ebf287b4311f4c18">https://gist.github.com/DatenMetzgerX/2a96ebf287b4311f4c18</a> that I believe was intended to do what I'm hoping to accomplish, but in it's current form I don't see how. It assigns an instance of MemoryFs to all of the resolvers. I've tried assigning node's fs module, but no dice. </p>

<p>So in short, I'm trying to set an entry point to an in memory string of raw javascript, but still have require and import statements resolved to node_modules on disk.</p>

<p><strong>UPDATE</strong></p>

<p>I've been able to get the result I'm looking for but it's not pretty. I'm basically overriding the implementation of #stat and #readFile in MemoryFS
to check the real filesystem if it gets any request for a file that doesn't exist in memory. I could clean this up a bit by subclassing MemoryFS instead of swapping method implementations at runtime, but the idea would still be the same.</p>

<p><strong>Working solution</strong></p>

<pre><code>import webpack from 'webpack';<font></font>
import JsonLoader from 'json-loader';<font></font>
import MemoryFS from 'memory-fs';<font></font>
import UglifyJS from "uglify-js";<font></font>
import thenify from 'thenify';<font></font>
import path from 'path';<font></font>
import fs from 'fs';<font></font>
import root from 'app-root-path';<font></font>
/*<font></font>
* Provide webpack with an instance of MemoryFS for<font></font>
* in-memory compilation. We're currently overriding<font></font>
* #stat and #readFile. Webpack will ask MemoryFS for the <font></font>
* entry file, which it will find successfully. However, <font></font>
* all dependencies are on the real filesystem, so any require <font></font>
* or import statements will fail. When that happens, our wrapper <font></font>
* functions will then check fs for the requested file. <font></font>
*/<font></font>
const memFs = new MemoryFS();<font></font>
const statOrig = memFs.stat.bind(memFs);<font></font>
const readFileOrig = memFs.readFile.bind(memFs);<font></font>
memFs.stat = function (_path, cb) {<font></font>
    statOrig(_path, function(err, result) {<font></font>
        if (err) {<font></font>
            return fs.stat(_path, cb);<font></font>
        } else {<font></font>
            return cb(err, result);<font></font>
        }<font></font>
    });<font></font>
};<font></font>
memFs.readFile = function (path, cb) {<font></font>
    readFileOrig(path, function (err, result) {<font></font>
        if (err) {<font></font>
            return fs.readFile(path, cb);<font></font>
        } else {<font></font>
            return cb(err, result);<font></font>
        }<font></font>
    });<font></font>
};<font></font>
<font></font>
<font></font>
export default function* compile(code) {<font></font>
    // Setup webpack <font></font>
    //create a directory structure in MemoryFS that matches<font></font>
    //the real filesystem<font></font>
    const rootDir = root.toString();<font></font>
    //write code snippet to memoryfs<font></font>
    const outputName = `file.js`;<font></font>
    const entry = path.join(rootDir, outputName);<font></font>
    const rootExists = memFs.existsSync(rootDir);<font></font>
    if (!rootExists) {<font></font>
        memFs.mkdirpSync(rootDir);<font></font>
    }<font></font>
    memFs.writeFileSync(entry, code);<font></font>
    //point webpack to memoryfs for the entry file<font></font>
    const compiler = webpack({<font></font>
        entry: entry,<font></font>
        output: {<font></font>
            filename: outputName<font></font>
        },<font></font>
        module: {<font></font>
            loaders: [<font></font>
                { test: /\.json$/, loader: 'json' }<font></font>
            ]<font></font>
        }<font></font>
    });<font></font>
    compiler.run = thenify(compiler.run);<font></font>
<font></font>
    //direct webpack to use memoryfs for file input<font></font>
    compiler.inputFileSystem = memFs;<font></font>
    compiler.resolvers.normal.fileSystem = memFs;<font></font>
<font></font>
    //direct webpack to output to memoryfs rather than to disk<font></font>
    compiler.outputFileSystem = memFs;<font></font>
    const stats = yield compiler.run();<font></font>
    //remove entry from memory. we're done with it<font></font>
    memFs.unlinkSync(entry);<font></font>
    const errors = stats.compilation.errors;<font></font>
    if (errors &amp;&amp; errors.length &gt; 0) {<font></font>
        //if there are errors, throw the first one<font></font>
        throw errors[0];<font></font>
    }<font></font>
    //retrieve the output of the compilation<font></font>
    const res = stats.compilation.assets[outputName].source(); <font></font>
    return res;<font></font>
}<font></font>
</code></pre>

<p><strong>Usage</strong></p>

<pre><code>var code = "var _ = require('underscore'); console.log(_);";<font></font>
var bundle = yield compile(code); //is a valid js bundle containing the underscore source and a log statement logging _.<font></font>
</code></pre>

<p>If there's not a better way, then I'll definitely encapsulate this into a subclass of MemoryFS, but I'm hoping there's a more sane way to accomplish this with Webpack's api.</p></div>
    {% endraw %}
  </div>
  <p style="height: 0;width:0;overflow: hidden;"> 第3926篇《在内存中编译Webpack，但解析为磁盘上的node_modules》来自Winter(https://github.com/aiyld/aiyld.github.io)的站点</p>
  <div class="discuss-wrapper">
    {% include discussTitle.html info=page %}
    {% raw %}
    <div class="discuss-item">
        <div class="discuss-parent">
          <div class="discuss-meta">
            <span class="discuss-user">Tom凯</span>
            <span class="discuss-time">2020.04.03</span>
          </div>
          <div class="discuss-comment"><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">代替memory-fs，unionfs / memfs / linkfs的组合应该会有所帮助。</font></font></p>

<ul>
<li><p><a href="https://npmjs.com/unionfs" rel="nofollow noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://npmjs.com/unionfs</font></font></a></p></li>
<li><p><a href="https://npmjs.com/memfs" rel="nofollow noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://npmjs.com/memfs</font></font></a></p></li>
<li><p><a href="https://npmjs.com/linkfs" rel="nofollow noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://npmjs.com/linkfs</font></font></a></p></li>
</ul></div>
        </div>
        
      </div>
    {% endraw %}
  </div>
<div>
